{"ast":null,"code":"var util=require('./util');function createNdefRecord(tnf,type,id,payload){if(tnf===undefined||type===undefined||id===undefined||payload===undefined){throw new Error('missing required param');}if(type instanceof Array){type=util.bytesToString(type);}if(!(id instanceof Array)){id=util.stringToBytes(id);}if(!(payload instanceof Array)){payload=util.stringToBytes(payload);}return{tnf:tnf,type:type,id:id,payload:payload};}function encodeNdefMessage(ndefRecords){var encodeTnf=function encodeTnf(_ref){var mb=_ref.mb,me=_ref.me,cf=_ref.cf,sr=_ref.sr,il=_ref.il,tnf=_ref.tnf;var value=tnf;if(mb){value=value|0x80;}if(me){value=value|0x40;}if(cf){value=value|0x20;}if(sr){value=value|0x10;}if(il){value=value|0x8;}return value;};var encoded=[],tnf_byte,record_type,payload_length,id_length,i,mb,me,cf=false,sr,il;for(i=0;i<ndefRecords.length;i++){mb=i===0;me=i===ndefRecords.length-1;sr=ndefRecords[i].payload.length<0xff;il=ndefRecords[i].id.length>0;tnf_byte=encodeTnf({mb:mb,me:me,cf:cf,sr:sr,il:il,tnf:ndefRecords[i].tnf});encoded.push(tnf_byte);record_type=util.stringToBytes(ndefRecords[i].type);encoded.push(record_type.length);if(sr){payload_length=ndefRecords[i].payload.length;encoded.push(payload_length);}else{payload_length=ndefRecords[i].payload.length;encoded.push(payload_length>>24);encoded.push(payload_length>>16);encoded.push(payload_length>>8);encoded.push(payload_length&0xff);}if(il){id_length=ndefRecords[i].id.length;encoded.push(id_length);}encoded=encoded.concat(record_type);if(il){encoded=encoded.concat(ndefRecords[i].id);}encoded=encoded.concat(ndefRecords[i].payload);}return encoded;}function decodeNdefMessage(ndefBytes){var decodeTnf=function decodeTnf(tnf_byte){return{mb:(tnf_byte&0x80)!==0,me:(tnf_byte&0x40)!==0,cf:(tnf_byte&0x20)!==0,sr:(tnf_byte&0x10)!==0,il:(tnf_byte&0x8)!==0,tnf:tnf_byte&0x7};};var bytes;if(ndefBytes instanceof Array){bytes=ndefBytes.slice(0);}else{throw new Error('ndef.decodeMessage requires a Buffer or an Array of bytes');}bytes=bytes.slice(0);var ndef_message=[],tnf_byte,header,type_length=0,payload_length=0,id_length=0,record_type=[],id=[],payload=[];while(bytes.length){tnf_byte=bytes.shift();header=decodeTnf(tnf_byte);type_length=bytes.shift();if(header.sr){payload_length=bytes.shift();}else{payload_length=(0xff&bytes.shift())<<24|(0xff&bytes.shift())<<16|(0xff&bytes.shift())<<8|0xff&bytes.shift();}id_length=header.il?bytes.shift():0;record_type=bytes.splice(0,type_length);id=bytes.splice(0,id_length);payload=bytes.splice(0,payload_length);ndef_message.push(createNdefRecord(header.tnf,record_type,id,payload));if(header.me){break;}}return ndef_message;}function equalToRecordType(record,tnf,type){if(record.tnf===tnf){if(Array.isArray(record.type)){return util.bytesToString(record.type)===type;}else{return record.type===type;}}return record.tnf===tnf&&record.type===type;}module.exports={createNdefRecord:createNdefRecord,encodeNdefMessage:encodeNdefMessage,decodeNdefMessage:decodeNdefMessage,equalToRecordType:equalToRecordType};","map":{"version":3,"names":["util","require","createNdefRecord","tnf","type","id","payload","undefined","Error","Array","bytesToString","stringToBytes","encodeNdefMessage","ndefRecords","encodeTnf","_ref","mb","me","cf","sr","il","value","encoded","tnf_byte","record_type","payload_length","id_length","i","length","push","concat","decodeNdefMessage","ndefBytes","decodeTnf","bytes","slice","ndef_message","header","type_length","shift","splice","equalToRecordType","record","isArray","module","exports"],"sources":["C:/appdev/btcwallet/src/node_modules/react-native-nfc-manager/ndef-lib/ndef.js"],"sourcesContent":["const util = require('./util');\n\nfunction createNdefRecord(tnf, type, id, payload) {\n  if (\n    tnf === undefined ||\n    type === undefined ||\n    id === undefined ||\n    payload === undefined\n  ) {\n    throw new Error('missing required param');\n  }\n\n  // store type as String so it's easier to compare\n  if (type instanceof Array) {\n    type = util.bytesToString(type);\n  }\n\n  // in the future, id could be a String\n  if (!(id instanceof Array)) {\n    id = util.stringToBytes(id);\n  }\n\n  // Payload must be binary\n  if (!(payload instanceof Array)) {\n    payload = util.stringToBytes(payload);\n  }\n\n  return {\n    tnf: tnf,\n    type: type,\n    id: id,\n    payload: payload,\n  };\n}\n\nfunction encodeNdefMessage(ndefRecords) {\n  const encodeTnf = ({mb, me, cf, sr, il, tnf}) => {\n    let value = tnf;\n\n    if (mb) {\n      value = value | 0x80;\n    }\n\n    if (me) {\n      value = value | 0x40;\n    }\n\n    // note if cf: me, mb, li must be false and tnf must be 0x6\n    if (cf) {\n      value = value | 0x20;\n    }\n\n    if (sr) {\n      value = value | 0x10;\n    }\n\n    if (il) {\n      value = value | 0x8;\n    }\n\n    return value;\n  };\n\n  let encoded = [],\n    tnf_byte,\n    record_type,\n    payload_length,\n    id_length,\n    i,\n    mb,\n    me, // messageBegin, messageEnd\n    cf = false, // chunkFlag TODO implement\n    sr, // boolean shortRecord\n    il; // boolean idLengthFieldIsPresent\n\n  for (i = 0; i < ndefRecords.length; i++) {\n    mb = i === 0;\n    me = i === ndefRecords.length - 1;\n    sr = ndefRecords[i].payload.length < 0xff;\n    il = ndefRecords[i].id.length > 0;\n    tnf_byte = encodeTnf({mb, me, cf, sr, il, tnf: ndefRecords[i].tnf});\n    encoded.push(tnf_byte);\n\n    // type is stored as String, converting to bytes for storage\n    record_type = util.stringToBytes(ndefRecords[i].type);\n    encoded.push(record_type.length);\n\n    if (sr) {\n      payload_length = ndefRecords[i].payload.length;\n      encoded.push(payload_length);\n    } else {\n      payload_length = ndefRecords[i].payload.length;\n      // 4 bytes\n      encoded.push(payload_length >> 24);\n      encoded.push(payload_length >> 16);\n      encoded.push(payload_length >> 8);\n      encoded.push(payload_length & 0xff);\n    }\n\n    if (il) {\n      id_length = ndefRecords[i].id.length;\n      encoded.push(id_length);\n    }\n\n    encoded = encoded.concat(record_type);\n\n    if (il) {\n      encoded = encoded.concat(ndefRecords[i].id);\n    }\n\n    encoded = encoded.concat(ndefRecords[i].payload);\n  }\n\n  return encoded;\n}\n\nfunction decodeNdefMessage(ndefBytes) {\n  const decodeTnf = (tnf_byte) => ({\n    mb: (tnf_byte & 0x80) !== 0,\n    me: (tnf_byte & 0x40) !== 0,\n    cf: (tnf_byte & 0x20) !== 0,\n    sr: (tnf_byte & 0x10) !== 0,\n    il: (tnf_byte & 0x8) !== 0,\n    tnf: tnf_byte & 0x7,\n  });\n\n  // ndefBytes can be an array of bytes e.g. [0x03, 0x31, 0xd1] or a Buffer\n  let bytes;\n  if (ndefBytes instanceof Array) {\n    bytes = ndefBytes.slice(0);\n  } else {\n    throw new Error(\n      'ndef.decodeMessage requires a Buffer or an Array of bytes',\n    );\n  }\n\n  bytes = bytes.slice(0); // clone since parsing is destructive\n  let ndef_message = [],\n    tnf_byte,\n    header,\n    type_length = 0,\n    payload_length = 0,\n    id_length = 0,\n    record_type = [],\n    id = [],\n    payload = [];\n\n  while (bytes.length) {\n    tnf_byte = bytes.shift();\n    header = decodeTnf(tnf_byte);\n\n    type_length = bytes.shift();\n\n    if (header.sr) {\n      payload_length = bytes.shift();\n    } else {\n      // next 4 bytes are length\n      payload_length =\n        ((0xff & bytes.shift()) << 24) |\n        ((0xff & bytes.shift()) << 16) |\n        ((0xff & bytes.shift()) << 8) |\n        (0xff & bytes.shift());\n    }\n\n    id_length = header.il ? bytes.shift() : 0;\n\n    record_type = bytes.splice(0, type_length);\n    id = bytes.splice(0, id_length);\n    payload = bytes.splice(0, payload_length);\n\n    ndef_message.push(createNdefRecord(header.tnf, record_type, id, payload));\n\n    if (header.me) {\n      break;\n    } // last message\n  }\n\n  return ndef_message;\n}\n\nfunction equalToRecordType(record, tnf, type) {\n  if (record.tnf === tnf) {\n    if (Array.isArray(record.type)) {\n      return util.bytesToString(record.type) === type;\n    } else {\n      return record.type === type;\n    }\n  }\n  return record.tnf === tnf && record.type === type;\n}\n\nmodule.exports = {\n  createNdefRecord,\n  encodeNdefMessage,\n  decodeNdefMessage,\n  equalToRecordType,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}