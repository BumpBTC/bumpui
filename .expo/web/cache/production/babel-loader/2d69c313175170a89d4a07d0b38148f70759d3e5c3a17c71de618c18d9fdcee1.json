{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import _objectWithoutProperties from\"@babel/runtime/helpers/objectWithoutProperties\";var _excluded=[\"colors\",\"locations\",\"startPoint\",\"endPoint\"];function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}import*as React from'react';import View from\"react-native-web/dist/exports/View\";import{normalizeColor}from'./normalizeColor';import{jsx as _jsx}from\"react/jsx-runtime\";export default function NativeLinearGradient(_ref){var colors=_ref.colors,locations=_ref.locations,startPoint=_ref.startPoint,endPoint=_ref.endPoint,props=_objectWithoutProperties(_ref,_excluded);var _React$useState=React.useState({height:1,width:1}),_React$useState2=_slicedToArray(_React$useState,2),_React$useState2$=_React$useState2[0],height=_React$useState2$.height,width=_React$useState2$.width,setLayout=_React$useState2[1];var linearGradientBackgroundImage=React.useMemo(function(){return getLinearGradientBackgroundImage(colors,locations,startPoint,endPoint,width,height);},[colors,locations,startPoint,endPoint,width,height]);return _jsx(View,_objectSpread(_objectSpread({},props),{},{style:[props.style,{backgroundImage:linearGradientBackgroundImage}],onLayout:function onLayout(event){var _event$nativeEvent$la=event.nativeEvent.layout,width=_event$nativeEvent$la.width,height=_event$nativeEvent$la.height;setLayout(function(oldLayout){if(width!==oldLayout.width||height!==oldLayout.height){return{height:height,width:width};}return oldLayout;});if(props.onLayout){props.onLayout(event);}}}));}export function getLinearGradientBackgroundImage(colors,locations,startPoint,endPoint){var width=arguments.length>4&&arguments[4]!==undefined?arguments[4]:1;var height=arguments.length>5&&arguments[5]!==undefined?arguments[5]:1;var gradientColors=calculateGradientColors(colors,locations);var angle=calculatePseudoAngle(width,height,startPoint,endPoint);return`linear-gradient(${angle}deg, ${gradientColors.join(', ')})`;}function calculatePseudoAngle(width,height,startPoint,endPoint){var getControlPoints=function getControlPoints(){var correctedStartPoint=[0,0];if(Array.isArray(startPoint)){correctedStartPoint=[startPoint[0]!=null?startPoint[0]:0.0,startPoint[1]!=null?startPoint[1]:0.0];}var correctedEndPoint=[0.0,1.0];if(Array.isArray(endPoint)){correctedEndPoint=[endPoint[0]!=null?endPoint[0]:0.0,endPoint[1]!=null?endPoint[1]:1.0];}return[correctedStartPoint,correctedEndPoint];};var _getControlPoints=getControlPoints(),_getControlPoints2=_slicedToArray(_getControlPoints,2),start=_getControlPoints2[0],end=_getControlPoints2[1];start[0]*=width;end[0]*=width;start[1]*=height;end[1]*=height;var py=end[1]-start[1];var px=end[0]-start[0];return 90+Math.atan2(py,px)*180/Math.PI;}function calculateGradientColors(colors,locations){return colors.map(function(color,index){var output=normalizeColor(color);if(locations&&locations[index]){var location=Math.max(0,Math.min(1,locations[index]));var percentage=location*100;return`${output} ${percentage}%`;}return output;});}","map":{"version":3,"names":["React","View","normalizeColor","jsx","_jsx","NativeLinearGradient","_ref","colors","locations","startPoint","endPoint","props","_objectWithoutProperties","_excluded","_React$useState","useState","height","width","_React$useState2","_slicedToArray","_React$useState2$","setLayout","linearGradientBackgroundImage","useMemo","getLinearGradientBackgroundImage","_objectSpread","style","backgroundImage","onLayout","event","_event$nativeEvent$la","nativeEvent","layout","oldLayout","arguments","length","undefined","gradientColors","calculateGradientColors","angle","calculatePseudoAngle","join","getControlPoints","correctedStartPoint","Array","isArray","correctedEndPoint","_getControlPoints","_getControlPoints2","start","end","py","px","Math","atan2","PI","map","color","index","output","location","max","min","percentage"],"sources":["C:\\appdev\\btcwallet\\src\\node_modules\\expo-linear-gradient\\src\\NativeLinearGradient.web.tsx"],"sourcesContent":["import * as React from 'react';\nimport { View } from 'react-native';\n\nimport { NativeLinearGradientPoint, NativeLinearGradientProps } from './NativeLinearGradient.types';\nimport { normalizeColor } from './normalizeColor';\n\nexport default function NativeLinearGradient({\n  colors,\n  locations,\n  startPoint,\n  endPoint,\n  ...props\n}: NativeLinearGradientProps): React.ReactElement {\n  const [{ height, width }, setLayout] = React.useState({\n    height: 1,\n    width: 1,\n  });\n\n  // TODO(Bacon): In the future we could consider adding `backgroundRepeat: \"no-repeat\"`. For more\n  // browser support.\n  const linearGradientBackgroundImage = React.useMemo(() => {\n    return getLinearGradientBackgroundImage(colors, locations, startPoint, endPoint, width, height);\n  }, [colors, locations, startPoint, endPoint, width, height]);\n\n  return (\n    <View\n      {...props}\n      style={[\n        props.style,\n        // @ts-ignore: [ts] Property 'backgroundImage' does not exist on type 'ViewStyle'.\n        { backgroundImage: linearGradientBackgroundImage },\n      ]}\n      onLayout={(event) => {\n        const { width, height } = event.nativeEvent.layout;\n\n        setLayout((oldLayout) => {\n          // don't set new layout state unless the layout has actually changed\n          if (width !== oldLayout.width || height !== oldLayout.height) {\n            return { height, width };\n          }\n\n          return oldLayout;\n        });\n\n        if (props.onLayout) {\n          props.onLayout(event);\n        }\n      }}\n    />\n  );\n}\n\n/**\n * Extracted to a separate function in order to be able to test logic independently.\n */\nexport function getLinearGradientBackgroundImage(\n  colors: readonly number[] | string[],\n  locations?: readonly number[] | null,\n  startPoint?: NativeLinearGradientPoint | null,\n  endPoint?: NativeLinearGradientPoint | null,\n  width: number = 1,\n  height: number = 1\n) {\n  const gradientColors = calculateGradientColors(colors, locations);\n  const angle = calculatePseudoAngle(width, height, startPoint, endPoint);\n  return `linear-gradient(${angle}deg, ${gradientColors.join(', ')})`;\n}\n\nfunction calculatePseudoAngle(\n  width: number,\n  height: number,\n  startPoint?: NativeLinearGradientPoint | null,\n  endPoint?: NativeLinearGradientPoint | null\n) {\n  const getControlPoints = (): NativeLinearGradientPoint[] => {\n    let correctedStartPoint: NativeLinearGradientPoint = [0, 0];\n    if (Array.isArray(startPoint)) {\n      correctedStartPoint = [\n        startPoint[0] != null ? startPoint[0] : 0.0,\n        startPoint[1] != null ? startPoint[1] : 0.0,\n      ];\n    }\n    let correctedEndPoint: NativeLinearGradientPoint = [0.0, 1.0];\n    if (Array.isArray(endPoint)) {\n      correctedEndPoint = [\n        endPoint[0] != null ? endPoint[0] : 0.0,\n        endPoint[1] != null ? endPoint[1] : 1.0,\n      ];\n    }\n    return [correctedStartPoint, correctedEndPoint];\n  };\n\n  const [start, end] = getControlPoints();\n  start[0] *= width;\n  end[0] *= width;\n  start[1] *= height;\n  end[1] *= height;\n  const py = end[1] - start[1];\n  const px = end[0] - start[0];\n\n  return 90 + (Math.atan2(py, px) * 180) / Math.PI;\n}\n\nfunction calculateGradientColors(\n  colors: readonly number[] | string[],\n  locations?: readonly number[] | null\n) {\n  return colors.map((color: number | string, index: number): string | void => {\n    const output = normalizeColor(color);\n    if (locations && locations[index]) {\n      const location = Math.max(0, Math.min(1, locations[index]));\n      // Convert 0...1 to 0...100\n      const percentage = location * 100;\n      return `${output} ${percentage}%`;\n    }\n    return output;\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}